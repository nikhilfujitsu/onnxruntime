#param tile_size
#param tile_size_k

#include "quantization/bitlinear_dequantize_lut.wgsl.template"

// Shared memory for intermediate results and LUT
var<workgroup> inter_results: array<array<output_element_t, tile_size_k>, tile_size>;
var<workgroup> shared_memory_LUT: array<u32, lut_size>;
// Storage for quantized A values and 5th elements
var<workgroup> tile_A: array<vec4<u32>, tile_size_k>;
var<workgroup> tile_A5: array<u32, tile_size_k>;
var<workgroup> scale_A: output_element_t;

// Scaled dot product of 5 packed integers for BitLinear.
fn SDP5AI(a1: vec4<u32>, b1: vec4<u32>, a2: u32, b2: u32) -> i32 {
    var local_sum = dot4I8Packed(a1[0], b1[0]);
    local_sum += dot4I8Packed(a1[1], b1[1]);
    local_sum += dot4I8Packed(a1[2], b1[2]);
    local_sum += dot4I8Packed(a1[3], b1[3]);
    local_sum += dot4I8Packed(a2, b2);
    return i32(local_sum);
}


$MAIN {
    // Initialize: Move the lookup table to shared memory
    if (local_idx < lut_size) {
        shared_memory_LUT[local_idx] = dequantize_LUT[local_idx];
    } else if ( local_idx == workgroup_size_x-1) {
        scale_A = scales_a[0];
    }
    let b_global_base = (workgroup_idx) * tile_size;

    // Handle each workgroup threads as a block of [tile_size][tile_size_k]
    let local_col = local_idx % tile_size_k; // column of k
    let local_row = local_idx / tile_size_k; // row of b

    // Process K in chunks. Each k_idx represents 4 uint32 values (16 i8 elements) from A
    // and corresponds to processing 4 bytes (20 ternary weights) from B
    for (var k_idx: u32 = 0; k_idx < uniforms.K20; k_idx += tile_size_k) {
        // Load Phase: Populate shared memory for the workgroup
        let k_load_offset = k_idx + local_idx;
        if (k_load_offset < uniforms.K20 && local_idx < tile_size_k) {
            tile_A[local_idx] = input_a[k_load_offset];
            tile_A5[local_idx] = input_a5[k_load_offset];
        }
        workgroupBarrier();

        let k_offset = k_idx + local_col;
        if (k_offset < uniforms.K20) {
            var own_a: vec4<u32> = tile_A[local_col];
            var own_a5: u32 = tile_A5[local_col];

            // Calculate intermediate results for multiple B rows
            let b_global = b_global_base + local_row;
            if (b_global < uniforms.N) {
                // B matrix layout: each row has K/20 uint32 values
                // Each uint32 contains 4 bytes, each byte has 5 ternary weights
                let b_offset = b_global * uniforms.K20 + k_offset;
                let b_value = input_b[b_offset];

                // Process each of the 4 bytes in the uint32
                var own_b: vec4<u32>;
                var own_b5: vec4<i32>;
                for (var byte_idx = 0u; byte_idx < 4u; byte_idx++) {
                    let b_byte = (b_value >> (byte_idx * 8)) & 0xFF;
                    // Get the first 4 dequantized values using LUT
                    let b_dequantized: u32 = shared_memory_LUT[b_byte / 3];
                    own_b[byte_idx] = b_dequantized;
                    // Get the 5th value using modulo
                    let b5_value = i32((b_byte % 3) - 1);
                    own_b5[byte_idx] = b5_value;
                }
                // Compute partial dot product for this byte
                var accumulated_result = SDP5AI(own_a, vec4<u32>(own_b), own_a5, pack4xI8(own_b5));
                inter_results[local_row][local_col] += output_element_t(accumulated_result);
            }

        }
        workgroupBarrier();
    }

    if (local_idx < tile_size) {
        // Reduce sum to get final output
        var output_value = output_element_t(0);
        for (var k_vec = 0u; k_vec < tile_size_k; k_vec++) {
            output_value += inter_results[local_idx][k_vec];
        }

        let b_global = b_global_base + local_idx;
        let output_idx = b_global;
        if (b_global < uniforms.N) {
            output[output_idx] = output_value * scale_A * output_element_t(uniforms.scale_B);
        }
    }
}
